<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Community Watch & Vehicle Tracker v1.0.22</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600;700&display=swap" rel="stylesheet">
    
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Open Sans', sans-serif;
            height: 100vh;
            width: 100vw;
            overflow: hidden; 
        }
        #container {
            display: flex;
            flex-direction: row;
            height: 100vh;
        }
        #map {
            flex: 1;
            height: 100vh; 
        }
        
        #sidebar {
            position: relative;
            width: 350px;
            height: 100%;
            padding: 20px;
            background-color: #f5f5ff;
            overflow-y: auto;
            box-shadow: 2px 0 10px rgba(0,0,0,0.1);
            flex-shrink: 0;
            transition: width 0.3s ease-out, padding 0.3s ease-out;
        }
        #sidebar.minimized {
            width: 0;
            padding: 0;
            overflow: hidden;
        }
        
        #restore-panel-btn {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 1001;
            width: auto;
            padding: 10px 15px;
            background-color: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            display: none;
        }

        h1 {
            font-size: 1.2em; font-weight: 700;
            margin-top: 0;
            color: #333;
        }
        label {
            display: block;
            margin-top: 10px;
            margin-bottom: 5px;
            font-weight: 600;
            font-size: 0.9em;
        }
        input, select, button, textarea {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid #90caf9;
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 0.9em;
        }
        input[type="time"], input[type="number"] {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            box-sizing: border-box;
        }
        input[type="color"] {
            height: 34px;
            padding: 0;
        }
        
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
            margin-top: 10px;
        }
        button:hover {
            background-color: #45a049;
        }
        .watch-btn {
            background-color: #2196F3;
        }
        .watch-btn:hover {
            background-color: #0b7dda;
        }
        .suspicious-btn {
            background-color: #FF9800;
        }
        .suspicious-btn:hover {
            background-color: #e68900;
        }
        .area-btn {
            background-color: #FF00FF; 
        }
        .area-btn:hover {
            background-color: #cc00cc;
        }
        #find_cross_street_btn {
            background-color: #5bc0de;
        }
        #find_cross_street_btn:hover {
            background-color: #31b0d5;
        }
        #clear_filters_btn {
            background-color: #f0ad4e;
            margin-top: 5px;
        }
        
        .clear-all-btn {
            background-color: #d9534f;
            margin-top: 20px;
            padding: 12px 8px;
            font-size: 1em;
            font-weight: 600;
        }
        .clear-all-btn:hover {
            background-color: #c9302c;
        }
        
        .export-data-btn {
            background-color: #007bff;
            margin-top: 20px;
            padding: 12px 8px;
            font-size: 1em;
            font-weight: 600;
            display: block; 
            text-align: center;
        }
        .export-data-btn:hover {
            background-color: #0056b3;
        }

        .instruction {
            background-color: #e3f2fd;
            padding: 10px;
            border-radius: 5px;
            font-size: 0.85em;
            margin-bottom: 15px;
            border-left: 4px solid #2196F3;
        }
        #feedback_message {
            padding: 10px;
            margin-bottom: 15px;
            border-radius: 5px;
            font-size: 0.9em;
            font-weight: 600;
            text-align: center;
            display: none;
        }
        .feedback-success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .feedback-error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .filter-error {
            color: #d9534f;
            font-size: 0.8em;
            margin-top: -5px;
            margin-bottom: 10px;
            display: none;
        }
        .marker-legend {
            background: white;
            padding: 10px;
            border-radius: 5px;
            margin-top: 15px;
            font-size: 0.85em;
        }
        .legend-item {
            margin: 5px 0;
            display: flex;
            align-items: center;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 10px;
            border: 2px solid #333;
        }
        .legend-circle {
            border-radius: 50%;
        }
        .legend-square {
            border-radius: 3px;
        }
        .legend-area {
        .marker-section {
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 5px;
            background-color: #e0f7fa;
            border: 1px solid #b2ebf2;
        }
            border: 2px solid #333; 
            background-color: #f0f0f0; 
            border-radius: 3px;
        }
        .section-header {
            font-size: 0.95em; font-weight: 600;
            margin-top: 20px;
            margin-bottom: 0px;
            color: #555;
            padding: 10px 0;
            border-bottom: 2px solid #ddd;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
        }
        .accordion-content {
            padding-top: 15px;
            padding-bottom: 5px;
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out;
            max-height: 2000px; 
            overflow: hidden;
        }
        .accordion-content.collapsed {
            max-height: 0;
            padding-top: 0;
            padding-bottom: 0;
            opacity: 0;
        }
        .arrow {
            font-size: 1.2em;
            transition: transform 0.3s;
        }
        .arrow.rotated {
            transform: rotate(90deg);
        }
        #filter-section-content {
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 5px;
            background-color: #e0f7fa; 
            border: 1px solid #b2ebf2;
        }
        
        .leaflet-draw-toolbar {
            display: none !important;
        }

    </style>
</head>
<body>

    <div id="container">
        <button id="restore-panel-btn" onclick="toggleSidebar()">‚ò∞ Show Panel</button>
        <div id="sidebar">
            <h1>Community Watch & Vehicle Tracker</h1>
            <button id="minimize-panel-btn" onclick="toggleSidebar()" style="width: 100%; padding: 10px; background-color: #9C27B0; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; margin-bottom: 15px;">Minimize Panel</button>
            
            <div id="feedback_message" class="feedback-success"></div>

            <div class="instruction">
                <strong>Instructions:</strong><br>
                **Double-Tap/Click** on the map to set the location field to the **exact address**.<br>
                **Popups** appear on hover and disappear after 2 seconds. Click quickly to use buttons.
            </div>
            
            <div class="section-header filter-header" onclick="toggleAccordion('filter')">
                Filter Markers (Name/Plate/Time) <span class="arrow rotated">></span>
            </div>
            
            <div id="filter-accordion-content" class="accordion-content">
                <div id="filter-section-content">
                    
                    <label>Filter Text (Name/Plate):</label>
                    <input type="text" id="filter_input" onkeyup="filterMarkers()" placeholder="Search Name or License Plate...">
                    <small style="display: block; margin-top: -8px; color: #666;">Partial matches work.</small>

                    <label for="area_filter_select" style="margin-top: 15px;">Filter by Watch Area:</label>
                    <select id="area_filter_select" onchange="filterMarkers()">
                        <option value="">(Show All Areas)</option>
                    </select>
                    
                    <label for="cross_street_input" style="margin-top: 15px;">Find Cross Street:</label>
                    <input type="text" id="cross_street_input" placeholder="e.g., Lawrence and Western">
                    <button id="find_cross_street_btn" onclick="findCrossStreet()" style="margin-top: 0;">Find & Zoom</button>
                    <label style="margin-top: 15px;">Filter Watch Time:</label>
                    <small style="display: block; margin-bottom: 10px; color: #666;">Shows watch members whose shift overlaps the 1-hour time window below. (Hides Suspicious vehicles and Abductions).</small>

                    <label for="filter_single_time">Search Time (1-Hour Window):</label>
                    <input type="time" id="filter_single_time" oninput="filterMarkers()">
                    
                    <small style="display: block; margin-top: -8px; color: #666;">Example: Filtering for 9:00 AM will show watch members active between 9:00 AM and 10:00 AM.</small>

                    <button id="clear_filters_btn" onclick="clearFilters()">Clear All Filters</button>
                </div>
            </div>
            
            <div class="section-header" onclick="toggleAccordion('plates')">
                Quick Reference Plates <span class="arrow rotated">></span>
            </div>
            
            <div id="plates-accordion-content" class="accordion-content collapsed">
                <div class="marker-section">
                    <label for="reference_plates_list">Unformatted Plate List (Paste from chat):</label>
                    <textarea id="reference_plates_list" rows="5" placeholder="Enter one full description/plate per line."></textarea>
                    <button onclick="saveQuickReferencePlates()" style="background-color: #007bff; margin-top: 0;">Save Plate List</button>

                    <h3 style="font-size: 1em; margin-top: 15px; border-bottom: 1px solid #ddd; padding-bottom: 5px;">Check Plate / Filter List</h3>
                    <label for="check_plate_input">Text to Search:</label>
                    <input type="text" id="check_plate_input" placeholder="Search by description, plate, state..." oninput="checkPlateList()">
                    <div id="plate_check_feedback" style="margin-top: 10px; font-weight: 600; min-height: 25px; text-align: center;"></div>
                </div>
            </div>
            <div class="section-header" onclick="toggleAccordion('area')">
                Watch Area <span class="arrow rotated">></span>
            </div>
            
            <div id="area-accordion-content" class="accordion-content collapsed">
                <div class="marker-section">
                    <label for="area_name">Area Name/Label:</label>
                    <input type="text" id="area_name" placeholder="e.g., Sector 1, River North">
                    
                    <label for="area_color">Area Border Color:</label>
                    <input type="color" id="area_color" value="#0BA847"> 
                    <button id="draw_area_btn" class="area-btn" onclick="initDrawArea()">Draw New Area</button>
                    
                    <label style="margin-top: 15px;">Upload Shapefile (.zip):</label>
                    <input type="file" id="shapefile_upload" accept=".zip" onchange="handleShapefileUpload(event)">
                    <small style="display: block; margin-top: -8px; color: #666;">Upload .zip containing .shp, .shx, .dbf files</small>
                    
                    <h3 style="font-size: 1em; margin-top: 15px; border-bottom: 1px solid #ddd; padding-bottom: 5px;">Saved Areas</h3>
                    <div id="saved_areas_list">
                        <p style="font-size: 0.85em; color: #666; margin-top: 5px;">No areas saved.</p>
                    </div>
                </div>
            </div>
            <div class="section-header" onclick="toggleAccordion('watch')">
                Watch Members <span class="arrow rotated">></span>
            </div>
            
            <div id="watch-accordion-content" class="accordion-content collapsed">
                <div class="marker-section">
                    <label for="watch_type">Type:</label>
                    <select id="watch_type">
                        <option value="red">Vehicle (Red)</option>
                        <option value="green">Bike (Green)</option>
                        <option value="blue">On Foot (Blue)</option>
                    </select>
                    
                    <label for="watch_name">Name: <span style="color:red">*</span></label>
                    <input type="text" id="watch_name" placeholder="Enter name">
                    
                    <label for="watch_location">Location: <span style="color:red">*</span></label>
                    <input type="text" id="watch_location" placeholder="e.g., 4800 N Western Ave">
                    <small style="display: block; margin-top: -8px; margin-bottom: 10px; color: #666;">Type address or use double-tap on map.</small>
                    
                    <label for="watch_start_time">Watch Start Time (Optional):</label>
                    <input type="time" id="watch_start_time">

                    <label for="watch_end_time">Watch End Time (Optional):</label>
                    <input type="time" id="watch_end_time">
                    
                    <button id="watch_btn" class="watch-btn" onclick="prepareWatchMemberMarker()">Add Watch Member to Map</button>
                </div>
            </div>
            
            <div class="section-header" onclick="toggleAccordion('suspicious')">
                Suspicious Vehicles <span class="arrow rotated">></span>
            </div>
            
            <div id="suspicious-accordion-content" class="accordion-content collapsed">
                <div class="marker-section">
                    <label for="suspicious_location">Location: <span style="color:red">*</span></label>
                    <input type="text" id="suspicious_location" placeholder="e.g., 4800 N Western Ave">
                    <small style="display: block; margin-top: -8px; margin-bottom: 10px; color: #666;">Type address or use double-tap on map.</small>
                    
                    <label for="suspicious_description">Vehicle Description (Make/Model/Color): <span style="color:red">*</span></label>
                    <input type="text" id="suspicious_description" placeholder="e.g., White Ford Explorer">
                    
                    <label for="suspicious_plate">License Plate (Optional):</label>
                    <input type="text" id="suspicious_plate" placeholder="e.g., ABC-1234">

                    <label for="suspicious_confirmation_status">Confirmation Status (Optional):</label>
                    <select id="suspicious_confirmation_status">
                        <option value="Suspected">Suspected</option>
                        <option value="Confirmed">Confirmed</option>
                    </select>
                    
                    <label for="suspicious_time_last_seen">Time Last Seen (Optional):</label>
                    <input type="time" id="suspicious_time_last_seen">
                    
                    <label for="suspicious_direction">Direction of Travel (Optional):</label>
                    <select id="suspicious_direction">
                        <option value="">Select direction</option>
                        <option value="North">North</option>
                        <option value="South">South</option>
                        <option value="East">East</option>
                        <option value="West">West</option>
                        <option value="Northeast">Northeast</option>
                        <option value="Northwest">Northwest</option>
                        <option value="Southeast">Southeast</option>
                        <option value="Southwest">Southwest</option>
                        <option value="Stationary">Stationary</option>
                    </select>
                    
                    <label for="suspicious_notes">Notes (Optional):</label>
                    <input type="text" id="suspicious_notes" placeholder="Additional information">
                    
                    <button id="suspicious_btn" class="suspicious-btn" onclick="prepareSuspiciousMarker()">Add Suspicious Vehicle to Map</button>
                </div>
            </div>

            <div class="section-header" onclick="toggleAccordion('abductions')">
                Abductions <span class="arrow rotated">></span>
            </div>
            
            <div id="abductions-accordion-content" class="accordion-content collapsed">
                <div class="marker-section">
                    
                    <label for="abduction_status">Abduction Status (Optional):</label>
                    <select id="abduction_status">
                        <option value="Suspected">Suspected</option>
                        <option value="Confirmed">Confirmed</option>
                    </select>

                    <label for="abduction_time">Time (Optional):</label>
                    <input type="time" id="abduction_time">
                    
                    <label for="abduction_location">Location: <span style="color:red">*</span></label>
                    <input type="text" id="abduction_location" placeholder="e.g., 4800 N Western Ave">
                    <small style="display: block; margin-top: -8px; margin-bottom: 10px; color: #666;">Type address or use double-tap on map.</small>

                    <label for="abduction_persons">Number of Persons Abducted (Optional):</label>
                    <input type="number" id="abduction_persons" min="1" placeholder="e.g., 1">
                    
                    <label for="abduction_agents">Number of Agents (Optional):</label>
                    <input type="number" id="abduction_agents" min="1" placeholder="e.g., 3">
                    
                    <label for="abduction_notes">Notes (Optional):</label>
                    <input type="text" id="abduction_notes" placeholder="Additional information">
                    
                    <button id="abduction_btn" class="gov-btn" style="background-color: #f44336;" onclick="prepareAbductionMarker()">Report Abduction</button>
                </div>
            </div>
            
            <div class="section-header" onclick="toggleAccordion('false_alarm')">
                False Alarms <span class="arrow rotated">></span>
            </div>
            
            <div id="false_alarm-accordion-content" class="accordion-content collapsed">
                <div class="marker-section">
                    
                    <label for="false_alarm_location">Location: <span style="color:red">*</span></label>
                    <input type="text" id="false_alarm_location" placeholder="e.g., 4800 N Western Ave">
                    <small style="display: block; margin-top: -8px; margin-bottom: 10px; color: #666;">Type address or use double-tap on map.</small>

                    <label for="false_alarm_notes">Notes (What was reported, why was it false?): <span style="color:red">*</span></label>
                    <input type="text" id="false_alarm_notes" placeholder="e.g., Reported theft, turned out to be a misdelivered package.">
                    
                    <button id="false_alarm_btn" style="background-color: #6c757d;" onclick="prepareFalseAlarmMarker()">Report False Alarm</button>
                </div>
            </div>

            <div class="marker-legend">
                <strong>Legend:</strong>
                <div class="legend-item">
                    <div class="legend-color legend-circle" style="background-color: red;"></div>
                    Vehicle Watch
                </div>
                <div class="legend-item">
                    <div class="legend-color legend-circle" style="background-color: green;"></div>
                    Bike Watch
                </div>
                <div class="legend-item">
                    <div class="legend-color legend-circle" style="background-color: blue;"></div>
                    Foot Watch
                </div>
                <div class="legend-item">
                    <div class="legend-color legend-square" style="background-color: #FF9800;"></div>
                    Suspicious Vehicle
                </div>
                 <div class="legend-item">
                    <div class="legend-color legend-square" style="background-color: transparent; border-color: red; border-width: 0;">
                        <div style="font-size: 20px; line-height: 20px; color: red; text-align: center;">&#x26A0;</div> 
                    </div>
                    Abduction Event
                </div>
                <div class="legend-item">
                    <div class="legend-color legend-square" style="background-color: transparent; border-color: #6c757d; border-width: 0; display: flex; justify-content: center; align-items: center; width: 20px; height: 20px;">
                         <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiIgd2lkdGg9IjE0IiBoZWlnaHQ9IjE0IiBmaWxsPSIjNmM3NTdkIj48cGF0aCBkPSJNMjYuOTY2LDEyLjg2N2MtMC4wMDEsMC4wMDEtMC4wMDIsMC4wMDItMC4wMDMsMC4wMDNsLTAuMDM4LTAuMDM4YzAuMDAxLDAuMDAxLDAuMDAyLDAuMDAyLDAuMDAzLDAuMDAzbC04LjgxNC04LjgxNGMwLjAxMS0wLjAxMSwwLjAyMy0wLjAyMiwwLjAzNC0wLjAzM2M1LjExOC01LjExOCwxNC42OTktMi4zNjMsMTQuNjIyLDcuMjczYzAuMDE5LDQuNjE4LTEuNjY2LDguODYtNC42ODgsMTEuODgybC04LjgxMyw4LjgxNGMtMC4wMDIsMC4wMDItMC4wMDIsMC4wMDItMC4wMDMsMC4wMTRjLTAuNDk0LDEuNDcxLTEuMTY2LDMuMTk5LTEuNTM5LDQuMzM0Yy0wLjAwNCwwLjAyLTAuMDA3LDAuMDQxLTAuMDA3LDAuMDYyYy0wLjExMywwLjUyOC0wLjIyNCwxLjE1OC0wLjMyLDEuODA0Yy0wLjAyNiwwLjE2Ny0wLjAxOSwwLjMyOCwwLjAyLDAuNTAxYzAuMDY2LDAuMjg1LDAuMTcyLDAuNDksMC40MTMsMC42MTRjMC4wMDEsMCwwLjAwMSwwLDAuMDAxLDAsMC4wMDEsMCwwLjAwMiwwLjAwMSwwLjAwMywwLjAwMWMwLjAwMSwwLDYuNTU3LTMuNTgyLDExLjEzMy0xNC40NDdDNDMuMjMsOS4wNTEsMzUuODU1LDQuNTM4LDI2Ljk2NiwxMi44Njd6Ii8+PHBhdGggZD0iTTE3Ljg0OCwzMi43NzVjLTAuMjIxLTAuMDk3LTAuMzM3LTAuMjctMC4zODktMC40OTZjLTAuMDQ0LTAuMTk2LTAuMDU5LTAuMzgyLTAuMDIyLTAuNzhjMC4wODctMS41NzQsMC4zNDctMy42NDcsMC42NjQtNS42ODhjMC4wMDItMC4wMTYsMC4wMDItMC4wMzUsMC4wMTgtMC4wMzdsOC43ODUtOC43ODljMi41MzctMi41MzcsMy43NjYtNS44NzQsMy43NjUtOS40NjVjLTAuMDE1LTEyLjg3Ny0xNy43MDUtMTUuNTc1LTIyLjMyMi05LjMzNWMtMC4wNDEsMC4wNzItMC4wNDcsMC4xNjEtMC4wMDUsMC4yNTJjMC4wNDEsMC4wOTYsMC4xMjMsMC4xNTksMC4yMjQsMC4xNzl2MC4wMDJjMC4wNzksMC4wMTIsMC4xMzIsMC4wMTksMC4xMzIsMC4wMTljMTAuNDE0LDAsMTAuNDE0LDAsMTAuNDE0LDEuNDc5VjMyLjk3NkgwVjEuMzIzQzAsMC45MSwwLjUxMiwwLjUwMywxLjAyMywwLjUwM2MxMC4wNTEsMCwxMi41MzQsMCwxMy4xNTUsMGMwLjQ4MSwwLDAuODgyLDAuNDE2LDAuODgyLDAuOTIxdjI5LjkxM0gyLjA0N3YxLjM0MUgxNy44NDhWMzIuNzc1eiIvPjwvc3ZnPg==" style="filter: invert(47%) sepia(21%) saturate(306%) hue-rotate(175deg) brightness(97%) contrast(90%);">
                    </div>
                    False Alarm
                </div>
                 <div class="legend-item">
                    <div class="legend-color legend-area" style="border-color: #333; background-color: #f0f0f0;"></div>
                    Watch Area (User Color)
                </div>
            </div>
            
            <button id="export_all_data_btn" class="export-data-btn" onclick="exportAllData()">
                ‚¨áÔ∏è Export ALL Data to Temporary Window
            </button>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/shpjs/3.6.3/shp.min.js"></script>
            
            <button id="clear_all_markers_btn" class="clear-all-btn" onclick="clearAllMarkers()">
                üóëÔ∏è Clear ALL Data (Markers & Watch Areas)
            </button>
            
        </div>
        
        <div id="map"></div>
    </div>
    
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
    
    <script>
        const map = L.map('map').setView([41.9676, -87.6888], 16);
        
        L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
            maxZoom: 20,
            subdomains: 'abcd'
        }).addTo(map);
        let markers = [];
        let drawnAreas = []; 
        let drawnItems = new L.FeatureGroup(); 
        let polygonHandler; 
        let referencePlatesData = []; 
        let popupTimeout; 
        map.addLayer(drawnItems);
        function bindHoverBehavior(layer, contentBuilder) {
            
            if (layer.areaData && layer.areaData.type === 'rectangle') {
                 return;
            }

            const initialContent = layer.markerData ? contentBuilder(layer.markerData, layer.markerIndex) : 'Loading...';
            layer.bindPopup(initialContent); 
            
            layer.on('mouseover', function (e) {
                clearTimeout(popupTimeout);
                
                let data = layer.markerData;
                let index = layer.markerIndex;
                let content;
                
                if (data.type === 'watch') {
                    content = buildWatchMemberPopup(data, index);
                } else if (data.type === 'suspicious') {
                    content = buildSuspiciousPopup(data, index);
                } else if (data.type === 'abduction') {
                    content = buildAbductionPopup(data, index);
                } else if (data.type === 'false_alarm') {
                    content = buildFalseAlarmPopup(data, index);
                }

                layer.setPopupContent(content);
                layer.openPopup();
            });

            layer.on('mouseout', function (e) {
                popupTimeout = setTimeout(function () {
                    layer.closePopup();
                }, 2000);
            });

            layer.on('popupopen', function () {
                let popup = layer.getPopup();
                if (popup._container) {
                    L.DomEvent.on(popup._container, 'mouseover', function () {
                        clearTimeout(popupTimeout);
                    });
                    L.DomEvent.on(popup._container, 'mouseout', function () {
                        popupTimeout = setTimeout(function () {
                            layer.closePopup();
                        }, 2000);
                    });
                }
            });
        }
        
        
        function toggleAccordion(type) {
            const content = document.getElementById(type + '-accordion-content');
            const header = content.previousElementSibling; 
            const arrow = header.querySelector('.arrow');

            if (content.classList.contains('collapsed')) {
                content.classList.remove('collapsed');
                arrow.classList.add('rotated');
            } else {
                if (type === 'watch') resetFormButton('watch');
                if (type === 'suspicious') resetFormButton('suspicious');
                if (type === 'abductions') resetFormButton('abduction'); 
                if (type === 'false_alarm') resetFormButton('false_alarm');

                content.classList.add('collapsed');
                arrow.classList.remove('rotated');
            }
        }
        
        function toggleMobileSidebar() {
            const sidebar = document.getElementById('sidebar');
            const toggleButton = document.getElementById('sidebar-toggle');
            
            sidebar.classList.toggle('open');
            
            if (sidebar.classList.contains('open')) {
                toggleButton.innerHTML = '‚úï Close';
                toggleButton.style.backgroundColor = '#f44336';
            } else {
                toggleButton.innerHTML = '‚ò∞ Menu';
                toggleButton.style.backgroundColor = '#2196F3';
                
                resetFormButton('watch');
                resetFormButton('suspicious');
                resetFormButton('abduction');
                resetFormButton('false_alarm');
            }
        }
        
        
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const btn = document.getElementById('minimize-panel-btn');
            const restoreBtn = document.getElementById('restore-panel-btn');
            
            if (window.innerWidth >= 768) {
                sidebar.classList.toggle('minimized');
                if (sidebar.classList.contains('minimized')) {
                    btn.textContent = 'Show Panel';
                    if (restoreBtn) restoreBtn.style.display = 'block';
                } else {
                    btn.textContent = 'Minimize Panel';
                    if (restoreBtn) restoreBtn.style.display = 'none';
                }
            } else {
                sidebar.classList.remove('open');
            }
        }

        function displayFeedback(message, type = 'success') {
            const feedbackEl = document.getElementById('feedback_message');
            feedbackEl.innerHTML = message;
            feedbackEl.className = '';
            feedbackEl.classList.add(type === 'success' ? 'feedback-success' : 'feedback-error');
            feedbackEl.style.display = 'block';
            
            clearTimeout(feedbackEl.timer);
            feedbackEl.timer = setTimeout(() => {
                feedbackEl.style.display = 'none';
            }, 5000);
        }

        function clearAllMarkers() {
            const confirmed = confirm("Are you sure you want to clear ALL Watch Member, Suspicious Vehicle, Abduction, False Alarm markers, AND Watch Areas from the map? Quick Reference Plates will NOT be cleared. This action cannot be undone.");
            
            if (!confirmed) {
                displayFeedback('Clear ALL Data operation cancelled.', 'success');
                return;
            }

            markers.forEach(marker => map.removeLayer(marker));
            markers = []; 

            drawnItems.clearLayers();
            drawnAreas = []; 
            renderSavedAreasList();
            renderAreaFilterDropdown();

            displayFeedback('ALL Markers (Watch Members, Suspicious, Abductions, False Alarms) and Watch Areas have been cleared. Quick Reference Plates remain saved for this session.', 'success');
        }
        async function reverseGeocodeLatLng(lat, lng) {
            await new Promise(resolve => setTimeout(resolve, 100)); 
            
            try {
                const response = await fetch(
                    `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=18&addressdetails=1`,
                    { headers: { 'User-Agent': 'CommunityWatch/1.0.22' } }
                );
                const data = await response.json();
                
                if (data && data.address) {
                    const addr = data.address;
                    const road = addr.road || '';
                    const suburb = addr.suburb || addr.neighbourhood || '';
                    
                    if (road && suburb) {
                        return `${road}, ${suburb}`;
                    } else if (road) {
                        return road;
                    }
                }
                
                if (data && data.display_name) {
                    return data.display_name.split(',').slice(0, 2).join(',').trim();
                }
                
                return `${lat.toFixed(6)}, ${lng.toFixed(6)}`;

            } catch (error) {
                console.error('Reverse Geocoding error:', error);
                return `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
            }
        }
        
        function htmlEscape(str) {
            if (!str) return '';
            return str.replace(/&/g, '&amp;')
                      .replace(/</g, '&lt;')
                      .replace(/>/g, '&gt;')
                      .replace(/"/g, '&quot;')
                      .replace(/'/g, '&#039;');
        }

     
        function formatDataForHumanReadability(data) {
            let html = '';
            
            html += '<h2 style="color:#007bff; border-bottom: 2px solid #ddd; padding-bottom: 5px; margin-top: 30px;">1. Tracked Markers</h2>';
            if (data.markers.length === 0) {
                html += '<p>No marker data saved.</p>';
            } else {
                html += '<ul style="list-style-type: none; padding-left: 0;">';
                data.markers.forEach(item => {
                    const d = item.data;
                    let title = '';
                    let details = '';

                    const escapedLocation = htmlEscape(d.location);
                    const escapedNotes = htmlEscape(d.notes);
                    
                    if (d.type === 'watch') {
                        const escapedName = htmlEscape(d.name);
                        const escapedTypeLabel = htmlEscape(d.typeLabel);
                        const escapedTime = htmlEscape(d.time);
                        
                        title = `<span style="color:black; font-weight:bold;">[Watch Member] ${escapedName}</span>`;
                        details = `Type: ${escapedTypeLabel} | Shift: ${escapedTime || 'N/A'} | Location: ${escapedLocation} | Coords: ${item.lat.toFixed(6)}, ${item.lng.toFixed(6)}`;
                    } else if (d.type === 'suspicious') {
                        const escapedPlate = htmlEscape(d.plate);
                        const escapedDescription = htmlEscape(d.description);
                        const escapedConfirmationStatus = htmlEscape(d.confirmationStatus);
                        const escapedTimeLastSeen12 = htmlEscape(d.timeLastSeen12);
                        const escapedDirection = htmlEscape(d.direction);

                        title = `<span style="color:#FF9800; font-weight:bold;">[Suspicious Vehicle] ${escapedPlate || 'Plate N/A'} - ${escapedDescription}</span>`;
                        details = `Status: ${escapedConfirmationStatus || 'N/A'} | Last Seen: ${escapedTimeLastSeen12} moving ${escapedDirection || 'N/A'} | Location: ${escapedLocation} | Notes: ${escapedNotes || 'N/A'}`;
                    } else if (d.type === 'abduction') {
                        const escapedAbductionStatus = htmlEscape(d.abductionStatus);
                        const escapedTime12hr = htmlEscape(d.time12hr);
                        const escapedPersonsAbducted = htmlEscape(d.personsAbducted);
                        const escapedAgents = htmlEscape(d.agents);

                        title = `<span style="color:red; font-weight:bold;">[‚ö†Ô∏è Abduction] ${escapedAbductionStatus || 'N/A'}</span>`;
                        details = `Time: ${escapedTime12hr || 'N/A'} | Persons/Agents: ${escapedPersonsAbducted || 'N/A'}/${escapedAgents || 'N/A'} | Location: ${escapedLocation} | Notes: ${escapedNotes || 'N/A'}`;
                    } else if (d.type === 'false_alarm') {
                        title = `<span style="color:#6c757d; font-weight:bold;">[False Alarm]</span>`;
                        details = `Location: ${escapedLocation} | Details: ${escapedNotes}`;
                    }

                    html += `<li style="margin-bottom: 15px; border: 1px solid #eee; padding: 10px; border-radius: 4px; background-color: #f9f9f9;">
                                ${title}<br>
                                <span style="font-size: 0.9em; display: block; margin-top: 2px;">${details}</span>
                            </li>`;
                });
                html += '</ul>';
            }

            html += '<h2 style="color:#007bff; border-bottom: 2px solid #ddd; padding-bottom: 5px; margin-top: 30px;">2. Watch Areas</h2>';
            if (data.areas.length === 0) {
                html += '<p>No watch areas saved.</p>';
            } else {
                html += '<ul style="list-style-type: disc; padding-left: 20px;">';
                data.areas.forEach(area => {
                    const escapedAreaName = htmlEscape(area.name);
                    
                    const boundsText = area.boundsReadable ? 
                        `SW: ${htmlEscape(area.boundsReadable.SW)}<br>NW: ${htmlEscape(area.boundsReadable.NW)}<br>NE: ${htmlEscape(area.boundsReadable.NE)}<br>SE: ${htmlEscape(area.boundsReadable.SE)}` :
                        `Raw Coords: [${area.bounds.join(', ')}]`;
                        
                    html += `<li style="margin-bottom: 10px;">
                                <span style="font-weight:bold; color:${area.color || 'black'};">${escapedAreaName}</span> (Color: ${area.color})<br>
                                <span style="font-size: 0.9em; display: block; margin-top: 5px;">Corners (Nearest Streets):</span>
                                <span style="font-size: 0.9em; display: block; padding-left: 10px;">${boundsText}</span>
                            </li>`;
                });
                html += '</ul>';
            }
            
            html += '<h2 style="color:#007bff; border-bottom: 2px solid #ddd; padding-bottom: 5px; margin-top: 30px;">3. Quick Reference Plates</h2>';
            const plateList = data.quickReferencePlates.trim();
            if (plateList === 'No Quick Reference Plates saved.' || plateList === '') {
                html += '<p>No quick reference plates saved.</p>';
            } else {
                const escapedPlateList = htmlEscape(plateList);
                html += '<pre style="background-color: #eee; padding: 15px; border: 1px dashed #ccc; white-space: pre-wrap; word-wrap: break-word;">' 
                     + escapedPlateList
                     + '</pre>';
            }
            
            html += `<p style="margin...`;
            
            return html;
        }

        async function exportAllData() {
            const areasForExport = [];
            
            for (const area of drawnAreas) {
                const [lngSW, latSW, lngNE, latNE] = area.bounds;
                
                const sw = [latSW, lngSW];
                const nw = [latNE, lngSW];
                const ne = [latNE, lngNE];
                const se = [latSW, lngNE];

                const [sw_text, nw_text, ne_text, se_text] = await Promise.all([
                    reverseGeocodeLatLng(sw[0], sw[1]),
                    reverseGeocodeLatLng(nw[0], nw[1]),
                    reverseGeocodeLatLng(ne[0], ne[1]),
                    reverseGeocodeLatLng(se[0], se[1]),
                ]);

                areasForExport.push({
                    ...area,
                    boundsReadable: {
                        SW: sw_text,
                        NW: nw_text,
                        NE: ne_text,
                        SE: se_text
                    }
                });
            }

            const markersForExport = markers.map(marker => ({
                lat: marker.getLatLng().lat,
                lng: marker.getLatLng().lng,
                data: marker.markerData
            }));
            
            const plateListText = document.getElementById('reference_plates_list').value || 'No Quick Reference Plates saved.';

            const allData = {
                markers: markersForExport,
                areas: areasForExport,
                quickReferencePlates: plateListText,
                exportTime: new Date().toLocaleString()
            };

            const formattedHTML = formatDataForHumanReadability(allData);
            
            const newWindow = window.open('', '_blank');
            newWindow.document.write(`
                <html>
                <head>
                    <title>Community Watch Data Export - ${htmlEscape(allData.exportTime)}</title>
                    <style>
                        body { font-family: 'Open Sans', sans-serif; padding: 20px; background-color: #f4f7f6; }
                        h1 { color: #333; border-bottom: 3px solid #007bff; padding-bottom: 10px; }
                        /* Styling from formatDataForHumanReadability is retained */
                    </style>
                </head>
                <body>
                    <h1>Community Watch Data Export - ${htmlEscape(allData.exportTime)}</h1>
                    ${formattedHTML}
                    <p style="text-align: center; margin-top: 50px;">
                        <button onclick="window.print()" style="padding: 10px 20px; font-size: 0.95em; font-weight: 600; background-color: #28a745; color: white; border: none; border-radius: 5px; cursor: pointer;">Print / Save as PDF</button>
                    </p>
                </body>
                </html>
            `);
            newWindow.document.close();
            
            displayFeedback('Data exported to a new temporary window. Use "Print / Save as PDF" to save it permanently.', 'success');
        }

        
        function saveQuickReferencePlates() {
            const listText = document.getElementById('reference_plates_list').value;
            
            referencePlatesData = [];
            const lines = listText.split('\n').filter(line => line.trim() !== '');

            lines.forEach(line => {
                const originalText = line.trim();
                const lowerText = originalText.toLowerCase();
                
                let normalizedPlate = lowerText.replace(/[^a-z0-9]/g, '');
                
                referencePlatesData.push({
                    originalText: originalText,
                    searchText: lowerText,
                    normalizedPlate: normalizedPlate
                });
            });
            
            displayFeedback(`**${lines.length}** Quick Reference Plates saved for this session.`, 'success');
            checkPlateList();
        }

        function loadQuickReferencePlates() {
             document.getElementById('plate_check_feedback').textContent = "No quick plates loaded (session is non-persistent).";
             document.getElementById('plate_check_feedback').style.color = '#666';
        }
        
        function checkPlateList() {
            const input = document.getElementById('check_plate_input').value.toLowerCase().trim();
            const feedbackEl = document.getElementById('plate_check_feedback');

            if (input.length === 0) {
                feedbackEl.textContent = `Search the ${referencePlatesData.length} saved plates.`;
                feedbackEl.style.color = '#666';
                return;
            }

            const normalizedInput = input.replace(/[^a-z0-9]/g, '');

            const matches = referencePlatesData.filter(item => 
                item.searchText.includes(input) || 
                item.normalizedPlate.includes(normalizedInput)
            );

            if (matches.length > 0) {
                let html = `<strong>MATCH(ES) FOUND (${matches.length}):</strong><ul style="margin-top: 5px; margin-bottom: 0; padding-left: 20px; text-align: left; color: #333; font-weight: normal;">`;
                matches.forEach(match => {
                    const safeText = htmlEscape(match.originalText);
                    html += `<li>${safeText}</li>`;
                });
                
                feedbackEl.innerHTML = html;
                feedbackEl.style.color = 'green';
            } else {
                feedbackEl.textContent = `No match found for "${input}".`;
                feedbackEl.style.color = '#d9534f';
            }
        }

        function convert24hrTo12hr(time24) {
            if (!time24) return 'N/A';
            const [hour24, minute] = time24.split(':');
            let hour = parseInt(hour24, 10);
            const suffix = hour >= 12 ? 'PM' : 'AM';
            hour = ((hour + 11) % 12) + 1;
            return `${hour}:${minute} ${suffix}`;
        }
        

        function timeToMinutes(timeString) {
            if (!timeString) return null;
            const [hourStr, minuteStr] = timeString.split(':');
            return (parseInt(hourStr, 10) * 60) + parseInt(parseInt(minuteStr, 10));
        }


        async function geocodeChicagoAddress(address) {
            if (!address) return null;

            const CHICAGO_BBOX = '-88.20,41.44,-87.05,42.32'; 

            const queries = [];

            if (address.toLowerCase().includes(' and ') || address.includes('&')) {
                const streets = address.toLowerCase().split(/\s+and\s+|&/).map(s => s.trim());
                if (streets.length === 2) {
                    queries.push(`${streets[0]} & ${streets[1]}, Chicago, IL`);
                }
            }

            if (!address.toLowerCase().includes('chicago')) {
                queries.push(address + ', Chicago, IL');
            }

            queries.push(address);

            for (const query of queries) {
                try {
                    const response = await fetch(
                        `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=1&viewbox=${CHICAGO_BBOX}&bounded=1`,
                        { headers: { 'User-Agent': 'CommunityWatch/1.0.21' } }
                    );
                    const data = await response.json();

                    if (data && data.length > 0) {
                        return [parseFloat(data[0].lat), parseFloat(data[0].lon)];
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 300));

                } catch (error) {
                    console.error('Geocoding error:', error);
                }
            }

            return null;
        }

        async function findCrossStreet() {
            const address = document.getElementById('cross_street_input').value;
            
            if (!address) {
                displayFeedback('Please enter an intersection to find.', 'error');
                return;
            }

            displayFeedback('Geocoding intersection...', 'success');
            const coords = await geocodeChicagoAddress(address);

            if (coords) {
                map.setView(coords, 17);
                displayFeedback('Found location. Panning map.', 'success');
            } else {
                displayFeedback("Sorry, can't find streets within the Chicago area.", 'error');
            }
        }

        function createCircleIcon(color) {
            let bgColor = 'blue';
            if (color === 'red') bgColor = 'red';
            if (color === 'green') bgColor = 'green';
            
            return L.divIcon({
                className: 'custom-circle-icon',
                html: `<div style="
                    width: 24px; 
                    height: 24px; 
                    border-radius: 50%; 
                    background-color: ${bgColor}; 
                    border: 3px solid #333; 
                    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
                "></div>`,
                iconSize: [24, 24],
                iconAnchor: [12, 12]
            });
        }
        
        function createSuspiciousIcon(confirmationStatus) {
            const isConfirmed = confirmationStatus === 'Confirmed';
            const bgColor = isConfirmed ? '#FF9800' : '#FFEB3B';
            return L.divIcon({
                className: 'custom-square-icon',
                html: `<div style="
                    width: 24px; 
                    height: 24px; 
                    background-color: ${bgColor};
                    border: 3px solid #333; 
                    border-radius: 3px;
                    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
                "></div>`,
                iconSize: [24, 24],
                iconAnchor: [12, 12]
            });
        }
        
        function createAbductionIcon() {
            return L.divIcon({
                className: 'custom-abduction-icon',
                html: `<div style="font-size: 30px; line-height: 30px; color: red; text-align: center;">&#x26A0;</div>`,
                iconSize: [30, 30],
                iconAnchor: [15, 30]
            });
        }

        function createFalseAlarmIcon() {
            const svgPin = `data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiIgd2lkdGg9IjE0IiBoZWlnaHQ9IjE0IiBmaWxsPSIjNmM3NTdkIj48cGF0aCBkPSJNMjYuOTY2LDEyLjg2N2MtMC4wMDEsMC4wMDEtMC4wMDIsMC4wMDItMC4wMDMsMC4wMDNsLTAuMDM4LTAuMDM4YzAuMDAxLDAuMDAxLDAuMDAyLDAuMDAyLDAuMDAzLDAuMDAzbC04LjgxNC04LjgxNGMwLjAxMS0wLjAxMSwwLjAyMy0wLjAyMiwwLjAzNC0wLjAzM2M1LjExOC01LjExOCwxNC42OTktMi4zNjMsMTQuNjIyLDcuMjczYzAuMDE5LDQuNjE4LTEuNjY2LDguODYtNC42ODgsMTEuODgybC04LjgxMyw4LjgxNGMtMC4wMDIsMC4wMDItMC4wMDIsMC4wMDItMC4wMDMsMC4wMTRjLTAuNDk0LDEuNDcxLTEuMTY2LDMuMTk5LTEuNTM5LDQuMzM0Yy0wLjAwNCwwLjAyLTAuMDA3LDAuMDQxLTAuMDA3LDAuMDYyYy0wLjExMywwLjUyOC0wLjIyNCwxLjE1OC0wLjMyLDEuODA0Yy0wLjAyNiwwLjE2Ny0wLjAxOSwwLjMyOCwwLjAyLDAuNTAxYzAuMDY2LDAuMjg1LDAuMTcyLDAuNDksMC40MTMsMC42MTRjMC4wMDEsMCwwLjAwMSwwLDAuMDAxLDAsMC4wMDEsMCwwLjAwMiwwLjAwMSwwLjAwMywwLjAwMWMwLjAwMSwwLDYuNTU3LTMuNTgyLDExLjEzMy0xNC40NDdDNDMuMjMsOS4wNTEsMzUuODU1LDQuNTM4LDI2Ljk2NiwxMi44Njd6Ii8+PHBhdGggZD0iTTE3Ljg0OCwzMi43NzVjLTAuMjIxLTAuMDk3LTAuMzM3LTAuMjctMC4zODktMC40OTZjLTAuMDQ0LTAuMTk2LTAuMDU5LTAuMzgyLTAuMDIyLTAuNzhjMC4wODctMS41NzQsMC4zNDctMy42NDcsMC42NjQtNS42ODhjMC4wMDItMC4wMTYsMC4wMDItMC4wMzUsMC4wMTgtMC4wMzdsOC43ODUtOC43ODljMi41MzctMi41MzcsMy43NjYtNS44NzQsMy43NjUtOS40NjVjLTAuMDE1LTEyLjg3Ny0xNy43MDUtMTUuNTc1LTIyLjMyMi05LjMzNWMtMC4wNDEsMC4wNzItMC4wNDcsMC4xNjEtMC4wMDUsMC4yNTJjMC4wNDEsMC4wOTYsMC4xMjMsMC4xNTksMC4yMjQsMC4xNzl2MC4wMDJjMC4wNzksMC4wMTIsMC4xMzIsMC4wMTksMC4xMzIsMC4wMTljMTAuNDE0LDAsMTAuNDE0LDAsMTAuNDE0LDEuNDc5VjMyLjk3NkgwVjEuMzIzQzAsMC45MSwwLjUxMiwwLjUwMywxLjAyMywwLjUwM2MxMC4wNTEsMCwxMi41MzQsMCwxMyuMTU1LDBjMC40ODEsMCwwLjg4MiwwLjQxNiwwLjg4MiwwLjkyMXYyOS45MTNIMi4wNDd2MS4zNDFIMTcuODQ4VjMyLjc3NXoiLz48L3N2Zz4=`;
            
            return L.icon({
                iconUrl: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiIgd2lkdGg9IjI1IiBoZWlnaHQ9IjI1IiBmaWxsPSIjNmM3NTdkIj48cGF0aCBkPSJNMjYuOTY2LDEyLjg2N2MtMC4wMDEsMC4wMDEtMC4wMDIsMC4wMDItMC4wMDMsMC4wMDNsLTAuMDM4LTAuMDM4YzAuMDAxLDAuMDAxLDAuMDAyLDAuMDAyLDAuMDAzLDAuMDAzbC04LjgxNC04LjgxNGMwLjAxMS0wLjAxMSwwLjAyMy0wLjAyMiwwLjAzNC0wLjAzM2M1LjExOC01LjExOCwxNC42OTktMi4zNjMsMTQuNjIyLDcuMjczYzAuMDE5LDQuNjE4LTEuNjY2LDguODYtNC42ODgsMTEuODgybC04LjgxMyw4LjgxNGMtMC4wMDIsMC4wMDItMC4wMDIsMC4wMDItMC4wMDMsMC4wMTRjLTAuNDk0LDEuNDcxLTEuMTY2LDMuMTk5LTEuNTM5LDQuMzM0Yy0wLjAwNCwwLjAyLTAuMDA3LDAuMDQxLTAuMDA3LDAuMDYyYy0wLjExMywwLjUyOC0wLjIyNCwxLjE1OC0wLjMyLDEuODA0Yy0wLjAyNiwwLjE2Ny0wLjAxOSwwLjMyOCwwLjAyLDAuNTAxYzAuMDY2LDAuMjg1LDAuMTcyLDAuNDksMC40MTMsMC42MTRjMC4wMDEsMCwwLjAwMSwwLDAuMDAxLDAsMC4wMDEsMCwwLjAwMiwwLjAwMSwwLjAwMywwLjAwMWMwLjAwMSwwLDYuNTU3LTMuNTgyLDExLjEzMy0xNC40NDdDNDMuMjMsOS4wNTEsMzUuODU1LDQuNTM4LDI2Ljk2NiwxMi44Njd6Ii8+PHBhdGggZD0iTTE3Ljg0OCwzMi43NzVjLTAuMjIxLTAuMDk3LTAuMzM3LTAuMjctMC4zODktMC40OTZjLTAuMDQ0LTAuMTk2LTAuMDU5LTAuMzgyLTAuMDIyLTAuNzhjMC4wODctMS41NzQsMC4zNDctMy42NDcsMC42NjQtNS42ODhjMC4wMDItMC4wMTYsMC4wMDItMC4wMzUsMC4wMTgtMC4wMzdsOC43ODUtOC43ODljMi41MzctMi41MzcsMy43NjYtNS44NzQsMy43NjUtOS40NjVjLTAuMDE1LTEyLjg3Ny0xNy43MDUtMTUuNTc1LTIyLjMyMi05LjMzNWMtMC4wNDEsMC4wNzItMC4wNDcsMC4xNjEtMC4wMDUsMC4yNTJjMC4wNDEsMC4wOTYsMC4xMjMsMC4xNTksMC4yMjQsMC4xNzl2MC4wMDJjMC4wNzksMC4wMTIsMC4xMzIsMC4wMTksMC4xMzIsMC4wMTljMTAuNDE0LDAsMTAuNDE0LDAsMTAuNDE0LDEuNDc5VjMyLjk3NkgwVjEuMzIzQzAsMC45MSwwLjUxMiwwLjUwMywxLjAyMywwLjUwM2MxMC4wNTEsMCwxMi41MzQsMCwxMy4xNTUsMGMwLjQ4MSwwLDAuODgyLDAuNDE2LDAuODgyLDAuOTIxdjI5LjkxM0gyLjA0N3YxLjM0MUgxNy44NDhWMzIuNzc1eiIvPjwvc3ZnPg==',
                iconSize: [25, 41],
                iconAnchor: [12, 41],
                popupAnchor: [1, -34]
            });
        }
        
        function buildWatchMemberPopup(data, markerIndex) {
            const safeName = htmlEscape(data.name);
            const safeTypeLabel = htmlEscape(data.typeLabel);
            const safeTime = htmlEscape(data.time);
            const safeLocation = htmlEscape(data.location);

            let shiftInfo = safeTime && safeTime.trim() !== ' - ' ? `<strong>Shift:</strong> ${safeTime}<br>` : '';
            let popupContent = `
                <strong>${safeName}</strong> ${safeTypeLabel}<br>
                ${shiftInfo}
                <strong>Location:</strong> ${safeLocation}<br>
                <div style="display: flex; gap: 5px; margin-top: 10px;">
                    <button onclick="startMarkerEditing(${markerIndex})" style="flex-grow: 1; padding: 5px; background-color: #007bff; color: white; border: none; cursor: pointer; border-radius: 3px;">Edit</button>
                    <button onclick="deleteMarker(${markerIndex})" style="flex-grow: 1; padding: 5px; background-color: #f44336; color: white; border: none; cursor: pointer; border-radius: 3px;">Delete</button>
                </div>
            `;
            return popupContent;
        }

        function buildSuspiciousPopup(data, markerIndex) {
            const safeConfirmationStatus = htmlEscape(data.confirmationStatus);
            const safeDescription = htmlEscape(data.description);
            const safePlate = htmlEscape(data.plate);
            const safeLocation = htmlEscape(data.location);
            const safeTimeLastSeen12 = htmlEscape(data.timeLastSeen12);
            const safeDirection = htmlEscape(data.direction);
            const safeNotes = htmlEscape(data.notes);

            let plateInfo = data.plate ? `<strong>Plate:</strong> ${safePlate}<br>` : '';
            let lastSeenInfo = data.timeLastSeen12 !== 'N/A' && data.direction !== 'N/A' ? `<strong>Last Seen:</strong> ${safeTimeLastSeen12} moving ${safeDirection}<br>` : '';
            
            let popupContent = `
                <strong>${safeConfirmationStatus || 'Suspected'} Suspicious Vehicle</strong><br>
                <strong>Description:</strong> ${safeDescription}<br>
                ${plateInfo}
                <strong>Location:</strong> ${safeLocation}<br>
                ${lastSeenInfo}
            `;
            if (data.notes) { popupContent += `<strong>Notes:</strong> ${safeNotes}<br>`; }
            
            popupContent += `
                <div style="display: flex; gap: 5px; margin-top: 10px;">
                    <button onclick="startMarkerEditing(${markerIndex})" style="flex-grow: 1; padding: 5px; background-color: #007bff; color: white; border: none; cursor: pointer; border-radius: 3px;">Edit</button>
                    <button onclick="deleteMarker(${markerIndex})" style="flex-grow: 1; padding: 5px; background-color: #f44336; color: white; border: none; cursor: pointer; border-radius: 3px;">Delete</button>
                </div>
            `;
            return popupContent;
        }


        function buildAbductionPopup(data, markerIndex) {
            const safeAbductionStatus = htmlEscape(data.abductionStatus);
            const safeTime12hr = htmlEscape(data.time12hr);
            const safeLocation = htmlEscape(data.location);
            const safePersonsAbducted = htmlEscape(data.personsAbducted);
            const safeAgents = htmlEscape(data.agents);
            const safeNotes = htmlEscape(data.notes);

            let timeInfo = data.time12hr !== 'N/A' ? `<strong>Time:</strong> ${safeTime12hr}<br>` : '';
            let personsInfo = data.personsAbducted !== 'N/A' ? `<strong>Persons Abducted:</strong> ${safePersonsAbducted}<br>` : '';
            let agentsInfo = data.agents !== 'N/A' ? `<strong>Agents:</strong> ${safeAgents}<br>` : '';
            
            let popupContent = `
                <strong>‚ö†Ô∏è Abduction Event</strong><br>
                <strong>Status:</strong> ${safeAbductionStatus || 'Suspected'}<br>
                ${timeInfo}
                <strong>Location:</strong> ${safeLocation}<br>
                ${personsInfo}
                ${agentsInfo}
            `;
            if (data.notes) { popupContent += `<strong>Notes:</strong> ${safeNotes}<br>`; }
            
            popupContent += `
                <div style="display: flex; gap: 5px; margin-top: 10px;">
                    <button onclick="startMarkerEditing(${markerIndex})" style="flex-grow: 1; padding: 5px; background-color: #007bff; color: white; border: none; cursor: pointer; border-radius: 3px;">Edit</button>
                    <button onclick="deleteMarker(${markerIndex})" style="flex-grow: 1; padding: 5px; background-color: #f44336; color: white; border: none; cursor: pointer; border-radius: 3px;">Delete</button>
                </div>
            `;
            return popupContent;
        }

        function buildFalseAlarmPopup(data, markerIndex) {
            const safeLocation = htmlEscape(data.location);
            const safeNotes = htmlEscape(data.notes);
            
            let popupContent = `
                <strong>False Alarm Reported</strong><br>
                <strong>Location:</strong> ${safeLocation}<br>
                <strong>Details:</strong> ${safeNotes}<br>
                <div style="display: flex; gap: 5px; margin-top: 10px;">
                    <button onclick="startMarkerEditing(${markerIndex})" style="flex-grow: 1; padding: 5px; background-color: #007bff; color: white; border: none; cursor: pointer; border-radius: 3px;">Edit</button>
                    <button onclick="deleteMarker(${markerIndex})" style="flex-grow: 1; padding: 5px; background-color: #f44336; color: white; border: none; cursor: pointer; border-radius: 3px;">Delete</button>
                </div>
            `;
            return popupContent;
        }

        function createWatchMemberMarker(coords, data, isNew = false) {
            const icon = createCircleIcon(data.watchType);
            const marker = L.marker(coords, { icon: icon, draggable: true, autoPan: true });

            marker.markerData = data; 
            marker.markerIndex = markers.length;

            markers.push(marker);
            map.addLayer(marker);

            bindHoverBehavior(marker, buildWatchMemberPopup);

            marker.on('dragend', function (e) {
                updateMarkerLocationFromDrag(marker, e.target.getLatLng());
            });

            if (isNew) {
                map.setView(coords, 16); 
                marker.openPopup();
                setTimeout(() => marker.closePopup(), 3000);
            }
        }

        function createSuspiciousMarker(coords, data, isNew = false) {
            const icon = createSuspiciousIcon(data.confirmationStatus);
            const marker = L.marker(coords, { icon: icon, draggable: true, autoPan: true });

            marker.markerData = data;
            marker.markerIndex = markers.length;

            markers.push(marker);
            map.addLayer(marker);
            
            bindHoverBehavior(marker, buildSuspiciousPopup);
            
            marker.on('dragend', function (e) {
                updateMarkerLocationFromDrag(marker, e.target.getLatLng());
            });

            if (isNew) {
                map.setView(coords, 16);
                marker.openPopup();
                setTimeout(() => marker.closePopup(), 3000);
            }
        }
        
        function createAbductionMarker(coords, data, isNew = false) {
            const icon = createAbductionIcon();
            const marker = L.marker(coords, { icon: icon, draggable: true, autoPan: true });

            marker.markerData = data;
            marker.markerIndex = markers.length;

            markers.push(marker);
            map.addLayer(marker);
            
            bindHoverBehavior(marker, buildAbductionPopup);
            
            marker.on('dragend', function (e) {
                updateMarkerLocationFromDrag(marker, e.target.getLatLng());
            });

            if (isNew) {
                map.setView(coords, 16);
                marker.openPopup();
                setTimeout(() => marker.closePopup(), 3000);
            }
        }

        function createFalseAlarmMarker(coords, data, isNew = false) {
            const icon = createFalseAlarmIcon();
            const marker = L.marker(coords, { icon: icon, draggable: true, autoPan: true });

            marker.markerData = data;
            marker.markerIndex = markers.length;

            markers.push(marker);
            map.addLayer(marker);
            

            bindHoverBehavior(marker, buildFalseAlarmPopup);
            
            marker.on('dragend', function (e) {
                updateMarkerLocationFromDrag(marker, e.target.getLatLng());
            });

            if (isNew) {
                map.setView(coords, 16);
                marker.openPopup();
                setTimeout(() => marker.closePopup(), 3000);
            }
        }
        
        function deleteMarker(markerIndex) {
            const marker = markers.find(m => m.markerIndex === markerIndex);
            
            if (marker) {
                map.removeLayer(marker);
                
                markers = markers.filter(m => m.markerIndex !== markerIndex);
                
                markers.forEach((m, index) => {
                    m.markerIndex = index;
                    if (m.markerData.type === 'watch') {
                        m.setPopupContent(buildWatchMemberPopup(m.markerData, index));
                    } else if (m.markerData.type === 'suspicious') {
                        m.setPopupContent(buildSuspiciousPopup(m.markerData, index));
                    } else if (m.markerData.type === 'abduction') {
                        m.setPopupContent(buildAbductionPopup(m.markerData, index));
                    } else if (m.markerData.type === 'false_alarm') {
                        m.setPopupContent(buildFalseAlarmPopup(m.markerData, index));
                    }
                });

                filterMarkers();
                displayFeedback(`Marker for **${marker.markerData.name || marker.markerData.description || marker.markerData.location}** deleted.`, 'success');
            }
        }

        async function prepareWatchMemberMarker() {
            const watchType = document.getElementById('watch_type').value;
            const name = document.getElementById('watch_name').value.trim();
            const location = document.getElementById('watch_location').value.trim();
            const startTime24 = document.getElementById('watch_start_time').value;
            const endTime24 = document.getElementById('watch_end_time').value;

            if (!name || !location) {
                displayFeedback('Please fill out the required Watch Member fields (Name and Location).', 'error');
                return;
            }

            displayFeedback('Geocoding location...', 'success');
            const coords = await geocodeChicagoAddress(location);

            if (!coords) {
                displayFeedback('Could not find that location or it is outside the restricted Chicago area. Please try a different address or intersection.', 'error');
                return;
            }

            const time12hr = (startTime24 && endTime24) ? `${convert24hrTo12hr(startTime24)} - ${convert24hrTo12hr(endTime24)}` : 'N/A';
            const startMin = startTime24 ? timeToMinutes(startTime24) : 0;
            const endMin = endTime24 ? timeToMinutes(endTime24) : 1439;
            
            const typeSelect = document.getElementById('watch_type');
            const typeLabel = typeSelect.options[typeSelect.selectedIndex].text.split(' ')[0]; 

            const markerData = {
                type: 'watch',
                watchType: watchType,
                typeLabel: typeLabel,
                name: name,
                location: location,
                time24: (startTime24 && endTime24) ? `${startTime24} - ${endTime24}` : '',
                time: time12hr,
                startMin: startMin,
                endMin: endMin
            };

            createWatchMemberMarker(coords, markerData, true);
            displayFeedback(`Watch Member **${name}** added successfully! (Data will be lost on refresh/close)`, 'success');

            document.getElementById('watch_name').value = '';
            document.getElementById('watch_location').value = '';
            document.getElementById('watch_start_time').value = '';
            document.getElementById('watch_end_time').value = '';
        }

        async function prepareSuspiciousMarker() {
            const location = document.getElementById('suspicious_location').value.trim();
            const description = document.getElementById('suspicious_description').value.trim();
            const plate = document.getElementById('suspicious_plate').value.trim();
            const confirmationStatus = document.getElementById('suspicious_confirmation_status').value;
            const timeLastSeen24 = document.getElementById('suspicious_time_last_seen').value;
            const direction = document.getElementById('suspicious_direction').value;
            const notes = document.getElementById('suspicious_notes').value;
            
            if (!location || !description) {
                displayFeedback('Please fill out the required Suspicious Vehicle fields (Description and Location).', 'error');
                return;
            }

            displayFeedback('Geocoding location...', 'success');
            const coords = await geocodeChicagoAddress(location);
            
            if (!coords) {
                displayFeedback('Could not find that location or it is outside the restricted Chicago area. Please try a different address or intersection.', 'error');
                return;
            }

            const timeLastSeen12 = timeLastSeen24 ? convert24hrTo12hr(timeLastSeen24) : 'N/A';
            const timeLastSeenMin = timeLastSeen24 ? timeToMinutes(timeLastSeen24) : null;
            
            const markerData = {
                type: 'suspicious',
                location: location,
                description: description,
                plate: plate || 'N/A',
                confirmationStatus: confirmationStatus || 'Suspected',
                timeLastSeen24: timeLastSeen24 || '',
                timeLastSeen12: timeLastSeen12,
                timeLastSeenMin: timeLastSeenMin,
                direction: direction || 'N/A',
                notes: notes || ''
            };

            createSuspiciousMarker(coords, markerData, true);
            displayFeedback(`Suspicious Vehicle **${description}** added successfully! (Data will be lost on refresh/close)`, 'success');

            document.getElementById('suspicious_location').value = '';
            document.getElementById('suspicious_description').value = '';
            document.getElementById('suspicious_plate').value = '';
            document.getElementById('suspicious_confirmation_status').value = 'Suspected';
            document.getElementById('suspicious_time_last_seen').value = '';
            document.getElementById('suspicious_direction').value = '';
            document.getElementById('suspicious_notes').value = '';
        }

        async function prepareAbductionMarker() {
            const abductionStatus = document.getElementById('abduction_status').value;
            const time24hr = document.getElementById('abduction_time').value;
            const location = document.getElementById('abduction_location').value.trim();
            const personsAbducted = document.getElementById('abduction_persons').value;
            const agents = document.getElementById('abduction_agents').value;
            const notes = document.getElementById('abduction_notes').value;
            
            if (!location) {
                displayFeedback('Please fill out the required Abduction Event field (Location).', 'error');
                return;
            }

            displayFeedback('Geocoding location...', 'success');
            const coords = await geocodeChicagoAddress(location);
            
            if (!coords) {
                displayFeedback('Could not find that location or it is outside the restricted Chicago area. Please try a different address or intersection.', 'error');
                return;
            }

            const time12hr = time24hr ? convert24hrTo12hr(time24hr) : 'N/A';

            const markerData = {
                type: 'abduction',
                abductionStatus: abductionStatus || 'Suspected',
                time24hr: time24hr || '',
                time12hr: time12hr,
                location: location,
                personsAbducted: personsAbducted || 'N/A',
                agents: agents || 'N/A',
                notes: notes || ''
            };

            createAbductionMarker(coords, markerData, true);
            displayFeedback(`Abduction event at **${location}** reported successfully! (Data will be lost on refresh/close)`, 'success');

            document.getElementById('abduction_status').value = 'Suspected';
            document.getElementById('abduction_time').value = '';
            document.getElementById('abduction_location').value = '';
            document.getElementById('abduction_persons').value = '';
            document.getElementById('abduction_agents').value = '';
            document.getElementById('abduction_notes').value = '';
        }

        async function prepareFalseAlarmMarker() {
            const location = document.getElementById('false_alarm_location').value.trim();
            const notes = document.getElementById('false_alarm_notes').value.trim();

            if (!location || !notes) {
                displayFeedback('Please fill out the required False Alarm fields (Location and Notes).', 'error');
                return;
            }

            displayFeedback('Geocoding location...', 'success');
            const coords = await geocodeChicagoAddress(location);

            if (!coords) {
                displayFeedback('Could not find that location or it is outside the restricted Chicago area. Please try a different address or intersection.', 'error');
                return;
            }

            const markerData = {
                type: 'false_alarm',
                location: location,
                notes: notes,
                timestamp: new Date().toISOString()
            };

            createFalseAlarmMarker(coords, markerData, true);
            displayFeedback(`False Alarm at **${location}** reported successfully! (Data will be lost on refresh/close)`, 'success');

            document.getElementById('false_alarm_location').value = '';
            document.getElementById('false_alarm_notes').value = '';
        }

        function updateMarkerPopupAndIcon(marker, data) {
            const markerIndex = marker.markerIndex;
            if (data.type === 'watch') {
                marker.setIcon(createCircleIcon(data.watchType));
                marker.setPopupContent(buildWatchMemberPopup(data, markerIndex));
            } else if (data.type === 'suspicious') {
                marker.setIcon(createSuspiciousIcon(data.confirmationStatus));
                marker.setPopupContent(buildSuspiciousPopup(data, markerIndex));
            } else if (data.type === 'abduction') {
                marker.setPopupContent(buildAbductionPopup(data, markerIndex));
            } else if (data.type === 'false_alarm') {
                marker.setPopupContent(buildFalseAlarmPopup(data, markerIndex));
            }
        }
        
        async function updateMarkerLocationFromDrag(marker, newLatLng, shouldSave = true) {
            
            try {
                const newAddress = await reverseGeocodeLatLng(newLatLng.lat, newLatLng.lng);
                
                marker.markerData.location = newAddress;
                
                let inputId;
                if (marker.markerData.type === 'watch' && document.getElementById('watch_btn').classList.contains('editing-mode')) {
                    inputId = 'watch_location';
                } else if ((marker.markerData.type === 'government' || marker.markerData.type === 'suspicious') && document.getElementById('suspicious_btn').classList.contains('editing-mode')) {
                    inputId = 'suspicious_location';
                } else if (marker.markerData.type === 'abduction' && document.getElementById('abduction_btn').classList.contains('editing-mode')) {
                    inputId = 'abduction_location';
                } else if (marker.markerData.type === 'false_alarm' && document.getElementById('false_alarm_btn').classList.contains('editing-mode')) {
                    inputId = 'false_alarm_location';
                }
                
                if (inputId) {
                    document.getElementById(inputId).value = newAddress;
                }
                
                updateMarkerPopupAndIcon(marker, marker.markerData);
                
                if (shouldSave) {
                    displayFeedback(`Marker location updated to: **${newAddress}** (Data will be lost on refresh/close)`, 'success');
                }
                
            } catch (error) {
                console.error('Error in updateMarkerLocationFromDrag:', error);
                if (shouldSave) {
                    displayFeedback('Error updating location on drag. Data saved.', 'error');
                }
            }
        }

        function resetFormButton(type) {
            let btnId;
            let originalText;
            let originalColor;
            let originalHandler;

            if (type === 'watch') {
                btnId = 'watch_btn';
                originalText = 'Add Watch Member to Map';
                originalColor = '#2196F3';
                originalHandler = prepareWatchMemberMarker;
            } else if (type === 'suspicious') {
                btnId = 'suspicious_btn';
                originalText = 'Add Suspicious Vehicle to Map';
                originalColor = '#FF9800';
                originalHandler = prepareSuspiciousMarker;
            } else if (type === 'abduction') {
                btnId = 'abduction_btn';
                originalText = 'Report Abduction';
                originalColor = '#f44336';
                originalHandler = prepareAbductionMarker;
            } else if (type === 'false_alarm') {
                 btnId = 'false_alarm_btn';
                 originalText = 'Report False Alarm';
                 originalColor = '#6c757d';
                 originalHandler = prepareFalseAlarmMarker;
            } else {
                return;
            }

            const btn = document.getElementById(btnId);
            if (btn && btn.classList.contains('editing-mode')) {
                btn.textContent = originalText;
                btn.onclick = originalHandler;
                btn.style.backgroundColor = originalColor;
                btn.classList.remove('editing-mode');
            }
        }

        function startMarkerEditing(markerIndex) {
            const marker = markers.find(m => m.markerIndex === markerIndex);
            if (!marker) {
                displayFeedback('Error: Could not find the marker to edit.', 'error');
                return;
            }

            const type = marker.markerData.type;
            const data = marker.markerData;
            
            const typeMapping = { 'watch': 'watch', 'government': 'suspicious', 'suspicious': 'suspicious', 'abduction': 'abduction', 'false_alarm': 'false_alarm' };
            const btnType = typeMapping[type];

            setupMarkerEditingUI(markerIndex, btnType, data);
        }

        function setupMarkerEditingUI(markerIndex, type, data) {
            const marker = markers.find(m => m.markerIndex === markerIndex);
            
            const sections = ['watch', 'suspicious', 'abductions', 'false_alarm'];
            sections.forEach(secType => {
                const content = document.getElementById(secType + '-accordion-content');
                const header = content.previousElementSibling;
                const arrow = header ? header.querySelector('.arrow') : null;
                
                const markerTypeMatch = (secType === 'abductions' && type === 'abduction') || (secType === type);

                if (markerTypeMatch) {
                    content.classList.remove('collapsed');
                    if (arrow) arrow.classList.add('rotated');
                } else {
                    content.classList.add('collapsed');
                    if (arrow) arrow.classList.remove('rotated');
                    resetFormButton(secType === 'abductions' ? 'abduction' : secType);
                }
            });

            if (type === 'watch') {
                document.getElementById('watch_type').value = data.watchType;
                document.getElementById('watch_name').value = data.name;
                document.getElementById('watch_location').value = data.location;
                const [start24, end24] = data.time24 ? data.time24.split(' - ') : ['', ''];
                document.getElementById('watch_start_time').value = start24;
                document.getElementById('watch_end_time').value = end24;

            } else if (type === 'suspicious') { 
                document.getElementById('suspicious_location').value = data.location;
                document.getElementById('suspicious_description').value = data.description;
                document.getElementById('suspicious_plate').value = data.plate !== 'N/A' ? data.plate : '';
                document.getElementById('suspicious_confirmation_status').value = data.confirmationStatus || 'Suspected';
                document.getElementById('suspicious_time_last_seen').value = data.timeLastSeen24 || '';
                document.getElementById('suspicious_direction').value = data.direction !== 'N/A' ? data.direction : '';
                document.getElementById('suspicious_notes').value = data.notes;

            } else if (type === 'abduction') {
                document.getElementById('abduction_status').value = data.abductionStatus || 'Suspected';
                document.getElementById('abduction_time').value = data.time24hr || '';
                document.getElementById('abduction_location').value = data.location;
                document.getElementById('abduction_persons').value = data.personsAbducted !== 'N/A' ? data.personsAbducted : '';
                document.getElementById('abduction_agents').value = data.agents !== 'N/A' ? data.agents : '';
                document.getElementById('abduction_notes').value = data.notes;
            } else if (type === 'false_alarm') {
                 document.getElementById('false_alarm_location').value = data.location;
                 document.getElementById('false_alarm_notes').value = data.notes;
            }

            let btnId;
            let btnColor = '#4CAF50';
            
            if (type === 'watch') btnId = 'watch_btn';
            else if (type === 'suspicious') btnId = 'suspicious_btn';
            else if (type === 'abduction') btnId = 'abduction_btn';
            else if (type === 'false_alarm') btnId = 'false_alarm_btn';
            else return;

            const btn = document.getElementById(btnId);
            btn.textContent = 'Save Changes';
            
            btn.onclick = () => updateExistingMarker(markerIndex);
            
            btn.style.backgroundColor = btnColor;
            btn.classList.add('editing-mode');
            
            map.setView(marker.getLatLng(), 17);
        }

        async function updateExistingMarker(markerIndex) {
            const marker = markers.find(m => m.markerIndex === markerIndex);
            if (!marker) {
                displayFeedback('Error: Could not find the marker to update.', 'error');
                return;
            }

            const type = marker.markerData.type;
            let coords = marker.getLatLng();
            let originalLocation = marker.markerData.location;
            let newLocation = '';
            let newData = {};
            let btnType = ''; 

            if (type === 'watch') {
                btnType = 'watch';
                const watchType = document.getElementById('watch_type').value;
                const name = document.getElementById('watch_name').value.trim();
                newLocation = document.getElementById('watch_location').value.trim();
                const startTime24 = document.getElementById('watch_start_time').value;
                const endTime24 = document.getElementById('watch_end_time').value;
                
                if (!name || !newLocation) {
                    displayFeedback('Please fill out the required Watch Member fields (Name and Location).', 'error');
                    return;
                }

                const time12hr = (startTime24 && endTime24) ? `${convert24hrTo12hr(startTime24)} - ${convert24hrTo12hr(endTime24)}` : 'N/A';
                const startMin = startTime24 ? timeToMinutes(startTime24) : 0;
                const endMin = endTime24 ? timeToMinutes(endTime24) : 1439;
                
                const typeSelect = document.getElementById('watch_type');
                const typeLabel = typeSelect.options[typeSelect.selectedIndex].text.split(' ')[0]; 

                newData = {
                    type: 'watch',
                    watchType: watchType,
                    typeLabel: typeLabel,
                    name: name,
                    location: newLocation,
                    time24: (startTime24 && endTime24) ? `${startTime24} - ${endTime24}` : '',
                    time: time12hr,
                    startMin: startMin,
                    endMin: endMin
                };

            } else if (type === 'suspicious' || type === 'government') {
                btnType = 'suspicious';
                newLocation = document.getElementById('suspicious_location').value.trim();
                const description = document.getElementById('suspicious_description').value.trim();
                const plate = document.getElementById('suspicious_plate').value.trim();
                const confirmationStatus = document.getElementById('suspicious_confirmation_status').value;
                const timeLastSeen24 = document.getElementById('suspicious_time_last_seen').value;
                const direction = document.getElementById('suspicious_direction').value;
                const notes = document.getElementById('suspicious_notes').value;

                if (!newLocation || !description) {
                    displayFeedback('Please fill out the required Suspicious Vehicle fields (Description and Location).', 'error');
                    return;
                }
                
                const timeLastSeen12 = timeLastSeen24 ? convert24hrTo12hr(timeLastSeen24) : 'N/A';
                const timeLastSeenMin = timeLastSeen24 ? timeToMinutes(timeLastSeen24) : null;

                newData = {
                    type: 'suspicious',
                    location: newLocation,
                    description: description,
                    plate: plate || 'N/A',
                    confirmationStatus: confirmationStatus || 'Suspected',
                    timeLastSeen24: timeLastSeen24 || '',
                    timeLastSeen12: timeLastSeen12,
                    timeLastSeenMin: timeLastSeenMin,
                    direction: direction || 'N/A',
                    notes: notes || ''
                };

            } else if (type === 'abduction') {
                btnType = 'abduction';
                const abductionStatus = document.getElementById('abduction_status').value;
                const time24hr = document.getElementById('abduction_time').value;
                newLocation = document.getElementById('abduction_location').value.trim();
                const personsAbducted = document.getElementById('abduction_persons').value;
                const agents = document.getElementById('abduction_agents').value;
                const notes = document.getElementById('abduction_notes').value;
                
                if (!newLocation) {
                    displayFeedback('Please fill out the required Abduction Event field (Location).', 'error');
                    return;
                }

                const time12hr = time24hr ? convert24hrTo12hr(time24hr) : 'N/A';

                newData = {
                    type: 'abduction',
                    abductionStatus: abductionStatus || 'Suspected',
                    time24hr: time24hr || '',
                    time12hr: time12hr,
                    location: newLocation,
                    personsAbducted: personsAbducted || 'N/A',
                    agents: agents || 'N/A',
                    notes: notes || ''
                };
            } else if (type === 'false_alarm') {
                 btnType = 'false_alarm';
                 newLocation = document.getElementById('false_alarm_location').value.trim();
                 const notes = document.getElementById('false_alarm_notes').value.trim();

                 if (!newLocation || !notes) {
                     displayFeedback('Please fill out the required False Alarm fields (Location and Notes).', 'error');
                     return;
                 }

                 newData = {
                     type: 'false_alarm',
                     location: newLocation,
                     notes: notes,
                     timestamp: marker.markerData.timestamp
                 };
            }

            if (newLocation !== originalLocation) {
                displayFeedback('Location has been changed. Geocoding new location...', 'success');
                const newCoords = await geocodeChicagoAddress(newLocation);
                
                if (newCoords) {
                    coords = L.latLng(newCoords[0], newCoords[1]);
                } else {
                    displayFeedback(`Could not find the new location **${newLocation}** within the Chicago area. Marker location remains unchanged. Data updated.`, 'error');
                }
            }

            marker.markerData = newData;
            marker.setLatLng(coords);
            updateMarkerPopupAndIcon(marker, newData);

            displayFeedback(`${(type === 'government' || type === 'suspicious') ? 'Suspicious Vehicle' : type.charAt(0).toUpperCase() + type.slice(1)} marker updated successfully! (Data will be lost on refresh/close)`, 'success');
            
            resetFormButton(btnType);
            
            if (type === 'watch') {
                document.getElementById('watch_name').value = '';
                document.getElementById('watch_location').value = '';
                document.getElementById('watch_start_time').value = '';
                document.getElementById('watch_end_time').value = '';
            } else if (type === 'suspicious' || type === 'government') {
                document.getElementById('suspicious_location').value = '';
                document.getElementById('suspicious_description').value = '';
                document.getElementById('suspicious_plate').value = '';
                document.getElementById('suspicious_confirmation_status').value = 'Suspected';
                document.getElementById('suspicious_time_last_seen').value = '';
                document.getElementById('suspicious_direction').value = '';
                document.getElementById('suspicious_notes').value = '';
            } else if (type === 'abduction') {
                 document.getElementById('abduction_status').value = 'Suspected';
                document.getElementById('abduction_time').value = '';
                document.getElementById('abduction_location').value = '';
                document.getElementById('abduction_persons').value = '';
                document.getElementById('abduction_agents').value = '';
                document.getElementById('abduction_notes').value = '';
            } else if (type === 'false_alarm') {
                document.getElementById('false_alarm_location').value = '';
                document.getElementById('false_alarm_notes').value = '';
            }
        }
        
        function reverseGeocodeAndUpdateFields(latlng) {
            
            const locationInputIds = [
                'watch_location', 
                'suspicious_location', 
                'abduction_location', 
                'false_alarm_location'
            ];
            
            displayFeedback('Fetching address for location...', 'success');

            fetch(
                `https://nominatim.openstreetmap.org/reverse?format=json&lat=${latlng.lat}&lon=${latlng.lng}&zoom=18&addressdetails=1`,
                { headers: { 'User-Agent': 'CommunityWatch/1.0.21' } }
            )
            .then(response => response.json())
            .then(data => {
                let addressString = '';
                if (data && data.address) {
                    const address = data.address;
                    const houseNumber = address.house_number;
                    const road = address.road;
                    const neighbourhood = address.neighbourhood || address.suburb;
                    
                    if (houseNumber && road) {
                        addressString = `${houseNumber} ${road}`;
                    } else if (road) {
                        addressString = road;
                    } else if (neighbourhood) {
                        addressString = neighbourhood;
                    } else {
                        addressString = data.display_name;
                    }
                } else {
                    addressString = `${latlng.lat.toFixed(4)}, ${latlng.lng.toFixed(4)}`;
                }
                
                locationInputIds.forEach(id => {
                    const el = document.getElementById(id);
                    if (el) {
                        el.value = addressString;
                    }
                });
                
                displayFeedback(`Location set to: **${addressString}** in all marker forms.`, 'success');
            })
            .catch(error => {
                console.error('Reverse geocoding error:', error);
                displayFeedback('Failed to find address for coordinates.', 'error');
            });
        }

        function isTimeOverlap(watchStartMin, watchEndMin, searchStartMin, searchEndMin) {
            
            if (watchStartMin === null || watchEndMin === null) return true;

            if (watchStartMin <= watchEndMin) {
                return Math.max(watchStartMin, searchStartMin) < Math.min(watchEndMin, searchEndMin);
            } 
            else { 
                const endOfDay = 1440;
                const part1Overlap = Math.max(watchStartMin, searchStartMin) < Math.min(endOfDay, searchEndMin);
                const part2Overlap = Math.max(0, searchStartMin) < Math.min(watchEndMin, searchEndMin);
                
                return part1Overlap || part2Overlap;
            }
        }
        
        function clearFilters() {
            document.getElementById('filter_input').value = '';
            document.getElementById('filter_single_time').value = '';
            document.getElementById('area_filter_select').value = '';
            filterMarkers();
            displayFeedback('Filters cleared. Showing all markers.', 'success');
        }

        function filterMarkers() {
            const filterText = document.getElementById('filter_input').value.toLowerCase().trim();
            const areaFilterId = document.getElementById('area_filter_select').value;
            const singleTime24 = document.getElementById('filter_single_time').value;

            let searchStartMin = null;
            let searchEndMin = null;
            let isTimeFilterActive = !!singleTime24;
            
            if (isTimeFilterActive) {
                searchStartMin = timeToMinutes(singleTime24);
                searchEndMin = searchStartMin + 60;
            }
            
            let areaBounds = null;
            if (areaFilterId) {
                const areaData = drawnAreas.find(a => a.id == areaFilterId);
                if (areaData) {
                    areaBounds = areaData.bounds.map(parseFloat);
                }
            }

            markers.forEach(marker => {
                const data = marker.markerData;
                const coords = marker.getLatLng();

                let matchText = false;
                let matchTime = true;
                let matchArea = true;

                if (!filterText) {
                    matchText = true;
                } else {
                    if (data.type === 'watch') {
                        if (data.name.toLowerCase().includes(filterText) || data.location.toLowerCase().includes(filterText)) {
                            matchText = true;
                        }
                    } else if (data.type === 'suspicious' || data.type === 'government') {
                        if (data.plate.toLowerCase().includes(filterText) || data.description.toLowerCase().includes(filterText) || data.location.toLowerCase().includes(filterText)) {
                            matchText = true;
                        }
                    } else if (data.type === 'abduction') {
                        if (data.location.toLowerCase().includes(filterText) || (data.notes && data.notes.toLowerCase().includes(filterText))) {
                            matchText = true;
                        }
                    } else if (data.type === 'false_alarm') {
                        if (data.location.toLowerCase().includes(filterText) || (data.notes && data.notes.toLowerCase().includes(filterText))) {
                            matchText = true;
                        }
                    }
                }

                if (isTimeFilterActive) {
                    if (data.type === 'watch') {
                        if (!isTimeOverlap(data.startMin, data.endMin, searchStartMin, searchEndMin)) {
                            matchTime = false;
                        }
                    } else {
                        matchTime = false;
                    }
                }
                
                if (areaBounds) {
                    if (coords) {
                        matchArea = isLatLngInBounds(coords.lat, coords.lng, areaBounds);
                    } else {
                        matchArea = false;
                    }
                }

                if (matchText && matchTime && matchArea) {
                    marker.setOpacity(1.0);
                    marker.setLatLng(marker.getLatLng());
                } else {
                    marker.setOpacity(0);
                }
            });
            
            drawnItems.eachLayer(layer => {
                if (layer.areaData && layer.areaData.type === 'rectangle') {
                    if (!areaFilterId || layer.areaData.id == areaFilterId) {
                        layer.setStyle({ opacity: 0.7, fillOpacity: 0 });
                        if (layer.label) layer.label.setOpacity(1.0);
                    } else {
                        layer.setStyle({ opacity: 0, fillOpacity: 0 });
                        if (layer.label) layer.label.setOpacity(0);
                    }
                }
            });

            const filterActive = filterText || isTimeFilterActive || areaFilterId;
            if (filterActive) {
                const visibleCount = markers.filter(m => m.getOpacity() > 0).length;
                let filterMessage = `**${visibleCount}** markers are visible.`;
                
                if (filterText) filterMessage += ` (Text Filter: "${filterText}")`;
                if (isTimeFilterActive) filterMessage += ` (Time Filter: ${convert24hrTo12hr(singleTime24)} to ${convert24hrTo12hr(searchEndMin > 1439 ? '00:00' : `${Math.floor(searchEndMin / 60).toString().padStart(2, '0')}:${(searchEndMin % 60).toString().padStart(2, '0')}`)})`;
                if (areaFilterId) filterMessage += ` (Area: ${drawnAreas.find(a => a.id == areaFilterId).name})`;

                displayFeedback(filterMessage, 'success');
            } else {
                displayFeedback(`**${markers.length}** total markers are visible.`, 'success');
            }
        }
        
        function isLatLngInBounds(lat, lng, bounds) {
            const [lngSW, latSW, lngNE, latNE] = bounds;
            
            return lat >= latSW && lat <= latNE && lng >= lngSW && lng <= lngNE;
        }

        function saveAreas() {
            renderSavedAreasList();
            renderAreaFilterDropdown();
        }

        function loadAreas() {
             drawnItems.clearLayers();
             drawnAreas = [];
             renderSavedAreasList();
             renderAreaFilterDropdown();
        }
        
        function renderSavedAreasList() {
            const listEl = document.getElementById('saved_areas_list');
            listEl.innerHTML = '';

            if (drawnAreas.length === 0) {
                listEl.innerHTML = '<p style="font-size: 0.85em; color: #666; margin-top: 5px;">No areas saved.</p>';
                return;
            }

            drawnAreas.forEach(area => {
                const item = document.createElement('div');
                item.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 5px 0; border-bottom: 1px dashed #ddd;';
                
                const label = document.createElement('span');
                label.textContent = htmlEscape(area.name);
                label.style.fontWeight = 'bold';
                label.style.fontSize = '0.9em';
                label.style.color = area.color || '#000';
                label.style.borderLeft = `3px solid ${area.color || '#FF00FF'}`;
                label.style.paddingLeft = '5px';
                label.style.flex = '1';
                label.style.cursor = 'pointer';
                label.title = 'Click to edit name';
                
                const areaId = area.id;
                label.onclick = () => {
                    const newName = prompt('Enter new name for this area:', area.name);
                    if (newName && newName.trim()) {
                        renameArea(areaId, newName.trim());
                    }
                };
                
                const buttonGroup = document.createElement('span');
                buttonGroup.style.cssText = 'display: flex; gap: 5px;';

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Delete';
                deleteBtn.style.cssText = 'width: 50px; padding: 3px; background-color: #f44336; color: white; border: none; cursor: pointer; border-radius: 3px; font-size: 0.8em;';
                
                deleteBtn.onclick = () => {
                    deleteArea(areaId);
                };

                buttonGroup.appendChild(deleteBtn);
                
                item.appendChild(label);
                item.appendChild(buttonGroup);
                listEl.appendChild(item);
            });
        }
        
        function renderAreaFilterDropdown() {
             const select = document.getElementById('area_filter_select');
             select.innerHTML = '<option value="">(Show All Areas)</option>';
             drawnAreas.forEach(area => {
                 const option = document.createElement('option');
                 option.value = area.id;
                 option.textContent = htmlEscape(area.name);
                 select.appendChild(option);
             });
        }

        function initDrawArea() {
            const areaName = document.getElementById('area_name').value.trim();
            const areaColor = document.getElementById('area_color').value;

            if (!areaName) {
                displayFeedback('Please enter a name for the Watch Area first!', 'error');
                return;
            }
            
            map.tempAreaName = areaName;
            map.tempAreaColor = areaColor;
            
            const drawBtn = document.getElementById('draw_area_btn');
            drawBtn.disabled = true;
            drawBtn.textContent = 'Drawing... Click points on map, double-click to finish';

            if (!polygonHandler) {
                polygonHandler = new L.Draw.Polygon(map, {
                    shapeOptions: {
                        color: areaColor,
                        weight: 3,
                        opacity: 0.7,
                        fillOpacity: 0,
                        fillColor: areaColor
                    }
                });
            } else {
                polygonHandler.options.shapeOptions.color = areaColor;
                polygonHandler.options.shapeOptions.fillColor = areaColor;
                polygonHandler.options.shapeOptions.opacity = 0.7;
                polygonHandler.options.shapeOptions.fillOpacity = 0.5;
            }
            
            polygonHandler.enable();
        }
        
      
        
        function handleShapefileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            displayFeedback('Processing shapefile...', 'success');
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    shp(e.target.result).then(function(geojson) {
                        const areaColor = document.getElementById('area_color').value;
                        
                        geojson.features.forEach((feature, index) => {
                            const areaName = feature.properties.name || 
                                           feature.properties.NAME || 
                                           `Imported Area ${index + 1}`;
                            
                            if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {
                                const coords = feature.geometry.type === 'Polygon' 
                                    ? feature.geometry.coordinates[0] 
                                    : feature.geometry.coordinates[0][0];
                                
                                const latLngs = coords.map(coord => [coord[1], coord[0]]);
                                
                                const polygon = L.polygon(latLngs, {
                                    color: areaColor,
                                    weight: 3,
                                    opacity: 0.7,
                                    fillOpacity: 0,
                                    fillColor: areaColor,
                                    interactive: false
                                });
                                
                                const bounds = polygon.getBounds();
                                const areaData = {
                                    id: Date.now() + index,
                                    type: 'polygon',
                                    name: areaName,
                                    color: areaColor,
                                    bounds: [
                                        bounds.getSouthWest().lng, 
                                        bounds.getSouthWest().lat, 
                                        bounds.getNorthEast().lng, 
                                        bounds.getNorthEast().lat
                                    ],
                                    coordinates: latLngs
                                };
                                
                                polygon.areaData = areaData;
                                drawnItems.addLayer(polygon);
                                drawnAreas.push(areaData);
                                
                                const labelCenter = bounds.getCenter();
                                const labelIcon = L.divIcon({
                                    className: 'area-label',
                                    html: `<div style="text-align:center; font-weight:bold; color:white; background-color: rgba(51,51,51,0.7); padding: 5px 10px; border-radius: 5px; cursor: pointer;">${htmlEscape(areaName)}</div>`,
                                    iconSize: [areaName.length * 10 + 40, 30]
                                });
                                const label = L.marker(labelCenter, { 
                                    icon: labelIcon, 
                                    interactive: true
                                }).addTo(drawnItems);
                                
                                label.on('click', function() {
                                    deleteArea(areaData.id);
                                });
                                
                                polygon.label = label;
                            }
                        });
                        
                        saveAreas();
                        displayFeedback('Shapefile imported successfully!', 'success');
                    }).catch(function(error) {
                        console.error('Shapefile parse error:', error);
                        displayFeedback('Error parsing shapefile. Ensure it contains .shp, .shx, and .dbf files.', 'error');
                    });
                } catch (error) {
                    console.error('Shapefile load error:', error);
                    displayFeedback('Error loading shapefile.', 'error');
                }
            };
            reader.readAsArrayBuffer(file);
            
            event.target.value = '';
        }
        
        function renameArea(areaId, newName) {
            const area = drawnAreas.find(a => a.id === areaId);
            if (!area) return;
            
            area.name = newName;
            
            drawnItems.eachLayer(function(layer) {
                if (layer.areaData && layer.areaData.id === areaId) {
                    if (layer.label) {
                        drawnItems.removeLayer(layer.label);
                        
                        const bounds = layer.getBounds();
                        const labelCenter = bounds.getCenter();
                        const labelIcon = L.divIcon({
                            className: 'area-label',
                            html: `<div style="text-align:center; font-weight:bold; color:white; background-color: rgba(51,51,51,0.7); padding: 5px 10px; border-radius: 5px; cursor: pointer;">${htmlEscape(newName)}</div>`,
                            iconSize: [newName.length * 10 + 40, 30]
                        });
                        const label = L.marker(labelCenter, { 
                            icon: labelIcon, 
                            interactive: true
                        }).addTo(drawnItems);
                        
                        label.on('click', function() {
                            deleteArea(areaId);
                        });
                        
                        layer.label = label;
                    }
                    layer.areaData.name = newName;
                }
            });
            
            saveAreas();
            displayFeedback(`Area renamed to "${newName}"`, 'success');
        }
        function deleteArea(idToDelete) {
             const confirmed = confirm("Are you sure you want to delete this watch area?");
            
            if (!confirmed) return;
            
            let layerToDelete = null;
            drawnItems.eachLayer(function(layer) {
                if (layer.areaData && layer.areaData.id === idToDelete && (layer instanceof L.Rectangle || layer instanceof L.Polygon)) {
                    layerToDelete = layer;
                }
            });

            if (layerToDelete) {
                drawnItems.removeLayer(layerToDelete);
                if (layerToDelete.label) {
                    drawnItems.removeLayer(layerToDelete.label);
                }
            }
            
            const areaName = drawnAreas.find(a => a.id === idToDelete)?.name || 'Area';
            drawnAreas = drawnAreas.filter(area => area.id !== idToDelete);
            
            saveAreas();
            filterMarkers();
            displayFeedback(`Watch Area **${areaName}** deleted. (Data will be lost on refresh/close)`, 'success');
        }
        
        map.on(L.Draw.Event.CREATED, function (e) {
            const layer = e.layer;
            const areaName = map.tempAreaName;
            const areaColor = map.tempAreaColor;
            const bounds = layer.getBounds();
            
            let coordinates = null;
            if (layer instanceof L.Polygon) {
                coordinates = layer.getLatLngs()[0].map(latlng => [latlng.lat, latlng.lng]);
            }
            
            const areaData = {
                id: Date.now(),
                type: layer instanceof L.Polygon ? 'polygon' : 'rectangle',
                name: areaName,
                color: areaColor,
                bounds: [
                    bounds.getSouthWest().lng, 
                    bounds.getSouthWest().lat, 
                    bounds.getNorthEast().lng, 
                    bounds.getNorthEast().lat
                ],
                coordinates: coordinates
            };
            
            layer.areaData = areaData; 
            layer.options.interactive = false;
            layer.options.fillOpacity = 0;
            drawnItems.addLayer(layer); 
            drawnAreas.push(areaData);
            
            const labelCenter = bounds.getCenter();
            const labelIcon = L.divIcon({
                className: 'area-label',
                html: `<div style="text-align:center; font-weight:bold; color:white; background-color: rgba(51,51,51,0.7); padding: 5px 10px; border-radius: 5px; cursor: pointer;">${htmlEscape(areaName)}</div>`,
                iconSize: [areaName.length * 10 + 40, 30]
            });
            const label = L.marker(labelCenter, { 
                icon: labelIcon, 
                interactive: true
            }).addTo(drawnItems);
            
            label.on('click', function() {
                deleteArea(areaData.id);
            });
            
            layer.label = label;
            
            polygonHandler.disable();
            const drawBtn = document.getElementById('draw_area_btn');
            drawBtn.disabled = false;
            drawBtn.textContent = 'Draw New Area';

            saveAreas();
            displayFeedback(`Watch Area **${areaName}** added successfully! (Data will be lost on refresh/close)`, 'success');
        });
        
        map.on(L.Draw.Event.DRAWSTOP, function (e) {
            const drawBtn = document.getElementById('draw_area_btn');
             if (drawBtn.textContent === 'Drawing... Click points on map, double-click to finish') {
                drawBtn.disabled = false;
                drawBtn.textContent = 'Draw New Area';
            }
        });
        
        setTimeout(function() {
            map.invalidateSize({ pan: false });
            loadAreas();
            loadQuickReferencePlates();

            map.on('dblclick', function(e) {
                if (window.innerWidth < 768 && document.getElementById('sidebar').classList.contains('open')) {
                    return;
                }
                reverseGeocodeAndUpdateFields(e.latlng);
            });
            
            document.getElementById('filter-accordion-content').classList.remove('collapsed'); 
            document.getElementById('filter-accordion-content').previousElementSibling.querySelector('.arrow').classList.add('rotated');
            
            const sections = ['plates', 'area', 'watch', 'suspicious', 'abductions', 'false_alarm'];
            sections.forEach(type => {
                const content = document.getElementById(type + '-accordion-content');
                if (content) {
                    content.classList.add('collapsed');
                    const arrow = content.previousElementSibling.querySelector('.arrow');
                    if (arrow) {
                        arrow.classList.remove('rotated');
                    }
                }
            });
            
        }, 250); 

    </script>
</body>
</html>
